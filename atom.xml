<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://caesaryangs.github.io</id>
    <title>Stories</title>
    <updated>2021-06-09T12:04:48.694Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://caesaryangs.github.io"/>
    <link rel="self" href="https://caesaryangs.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://caesaryangs.github.io/images/avatar.png</logo>
    <icon>https://caesaryangs.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Stories</rights>
    <entry>
        <title type="html"><![CDATA[软件过程]]></title>
        <id>https://caesaryangs.github.io/post/software-process/</id>
        <link href="https://caesaryangs.github.io/post/software-process/">
        </link>
        <updated>2021-06-09T11:46:09.000Z</updated>
        <summary type="html"><![CDATA[<p>本文隶属于软件工程学习流程中。<br>
&quot;将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中&quot;。</p>
<hr>
]]></summary>
        <content type="html"><![CDATA[<p>本文隶属于软件工程学习流程中。<br>
&quot;将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中&quot;。</p>
<hr>
<!-- more -->
<h2 id="过程模型">过程模型</h2>
<ul>
<li>定义：是软件过程的抽象表示，有时叫做过程范例<br>
指的是一种包含过程本身，方法和工具的策略集合，其目的是有效的管理和交付软件产品</li>
<li><strong>四个基本活动：软件描述+软件设计和实验+软件有效性验证+软件进化</strong></li>
</ul>
<h3 id="软件过程模型">软件过程模型</h3>
<p>过程定义了：<strong>谁</strong>在<strong>做什么</strong>, 什么<strong>时间</strong>, 如何达到<strong>既定目标</strong><br>
过程的选择：根据项目的具体性质；开发方法和工具的选择；其它约束条件</p>
<h3 id="瀑布模型-the-waterfall-model">瀑布模型 The waterfall model</h3>
<p>将软件开发过程（需求描述和系统开发）进行清晰的阶段划分，将描述系统开发。</p>
<ul>
<li>瀑布式开发框架<br>
[image:1223FBFB-9C0C-4E9B-99EC-B577AD89EC93-19154-00003F2CB42B7BA6/截屏2021-06-09 下午4.53.44.png]</li>
<li>特点：</li>
<li>将项目硬生生分解为确切的阶段。委托事项在过程早期阶段清晰给出。很难响应用户需求的变更</li>
<li>仅适用于当需求较为清晰，且需求相对稳定的情况下。</li>
<li>大型项目中，异地协同开发时也较为适用。</li>
</ul>
<h3 id="进化式开发模式-evolutionary-development">进化式开发模式 Evolutionary development</h3>
<p>系统开发各个阶段没有清晰的界限，描述、开发、验证的工作交替进行。</p>
<ul>
<li>探索式开发
<ul>
<li>与用户一起工作，共同探索系统需求，直至最后交付系统。</li>
<li>开发是从需求较为清晰的部分开始，根据用户的建议逐渐向系统中添加功能。</li>
</ul>
</li>
<li>抛弃式原形
<ul>
<li>其目的是理解用户需求，然后再给出系统的一个较好的需求定义。</li>
<li>原型着重对客户需求理解较差的那部分的实验。</li>
</ul>
</li>
<li>进化式开发框架：<br>
[image:475BA5EF-99E0-4396-B78C-9AD26C5CE9BC-19154-00003F72BCB4A9B0/截屏2021-06-09 下午4.58.42.png]
<ul>
<li>问题
<ul>
<li>缺少过程的可见性：项目管理通常情况是靠经验来把握进度；</li>
<li>系统结构较差：由于频繁的变更，结构比较脆弱</li>
<li>需要额外的技术 (如原型设计技术等)</li>
</ul>
</li>
<li>应用
<ul>
<li>小型或中型系统，可采用进化式开发方法</li>
<li>大型系统中采用混合开发模式。</li>
</ul>
</li>
</ul>
</li>
<li>特点：
<ol>
<li>提高系统的可用性</li>
<li>更加贴切用户的需求</li>
<li>提升设计质量</li>
<li>提高可维护性</li>
<li>降低开发成本</li>
</ol>
</li>
</ul>
<h3 id="基于构件的软件工程开发模式-component-based-software-engineering">基于构件的软件工程（开发模式）  Component-based software engineering</h3>
<p>系统是基于已经存在的构件（组件）采用组装模式开发。</p>
<ul>
<li>基于重用的系统集成开发<br>
已经存在的构件；市场上提供的服务构件</li>
</ul>
<ul>
<li>过程阶段：<br>
组件分析；需求修改；基于重用的系统设计；开发和集成.</li>
</ul>
<!-- more -->
<h2 id="过程迭代">过程迭代</h2>
<p>当需求变更无法避免时，过程活动就会有规律的重复进行，这种开发我们称之为：“迭代开发过程”。<br>
两个典型的迭代过程应用模型：</p>
<h3 id="增量式开发incremental-delivery">增量式开发（Incremental delivery）</h3>
<p>区别于瀑布式开发的单一提交，增量式开发将需求分解成很多小的增量，每个增量对应每一部分的需求<br>
增量不分优先级<br>
要求：一旦增量开始启动，则该增量的需求就处于冻结状态，不允许进行变更。<br>
难度：增量的规模应该相对较小，（原则上不超过20000代码行），每个增量包含一定的系统功能。大多数系统需要一组基本服务。该基本服务在系统的许多地方都可以使用。</p>
<ul>
<li>增量式开发过程框架：<br>
[image:EBBA1DBF-DD29-4689-9F21-EBE4E85EFF63-19154-00004226B2E90D8E/截屏2021-06-09 下午7.18.10.png]</li>
<li>特点：
<ul>
<li>客户无需等到整个系统的实现。<br>
• 早期的增量同时担当了后续需求的原型<br>
• 项目总体失败的风险比较低。<br>
• 高优先级的增量会得到全面的测试。</li>
</ul>
</li>
</ul>
<h3 id="螺旋式开发spiral-development">螺旋式开发（Spiral development）</h3>
<ul>
<li>螺旋式开发过程图：<br>
[image:459A703D-D828-482B-BB2B-68760636E59D-19154-00004243481C9B6D/截屏2021-06-09 下午7.20.13.png]</li>
<li>扇区：
<ul>
<li>目标设置<br>
为项目的这个阶段定义专门目标。制定对过程和产品的约束，而且制定详细的管理计划。<br>
• 风险评估和规避<br>
分析项目风险，根据这些风险规避的策略方案。<br>
每一个项目风险确定以后要进行详细的分析，并采取措施规避这些风险。<br>
• 开发和有效性验证<br>
在风险预估以后，为系统选择开发模型<br>
进行开发，并进行各个阶段的验证<br>
• 规划<br>
对项目进行评审以确定是否需要进入螺旋线的下一个回路。如果决定继续，就要做出项目的下个阶段计划。</li>
</ul>
</li>
</ul>
<!-- more -->
<h2 id="过程活动">过程活动</h2>
<h3 id="软件描述">软件描述</h3>
<p>主要是理解并定义系统需要哪些服务以及找出开发和运行期间的约束条件。</p>
<ul>
<li>软件需求过程<br>
软件可行性研究；需求的抽取和分析；需求描述；需求有效性验证.</li>
</ul>
<h3 id="软件设计与实现">软件设计与实现</h3>
<p><strong>软件开发的实现阶段是把系统描述转换成一个可运行的系统的过程.</strong></p>
<ul>
<li>软件设计：软件设计是对实现软件的结构、系统的数据、系统组件间的接口以及所用的算法的描述</li>
<li>实现：将设计内容“翻译”为一个可执行程序的过程</li>
<li>设计与实现是相互独立，而其中又有着千丝万缕的关系。</li>
<li>软件设计过程图：<br>
[image:A52A02CA-9F94-4298-A5D8-508C8F897AF5-19154-00004296498F4830/截屏2021-06-09 下午7.26.11.png]</li>
</ul>
<ul>
<li><strong>编程与调试</strong>
<ul>
<li>将设计内容“翻译”成一段程序代码，并去除错误的过程</li>
<li>调试——一个诊断的过程</li>
</ul>
</li>
</ul>
<h3 id="软件有效性验证">软件有效性验证</h3>
<ul>
<li><strong>Verification and validation (V &amp; V) 的目的是在于验证系统实现了系统需求，同时该系统需求和用户的期望是相符的</strong></li>
<li>组件（或单元）测试<br>
测试单个的组件，以确保其操作的正确性。<br>
独立测试每个组件，而不受其他组件的影响</li>
<li>系统测试<br>
组件得以集成形成系统。<br>
侧重找出组件间非预期的交互行为和接口问题</li>
<li>验收测试<br>
用户参与进行的测试<br>
在运行前的最后阶段测试<br>
一般用用户提供的真实数据进行测试。</li>
</ul>
<h3 id="软件进化">软件进化</h3>
<ul>
<li>软件需要具备灵活性。</li>
<li>Build-Fix的开发模式已经不存在了，软件维护和软件开发的界限也越来越模糊了</li>
</ul>
<!-- more -->
<h2 id="应用软件过程及过程模型">应用软件过程及过程模型</h2>
<h3 id="软件工程是一种层次化技术">软件工程是一种层次化技术</h3>
<ul>
<li>从实践角度如何理解过程模型<br>
瀑布式模型Vs.通用过程框架<br>
增量开发 Vs. 通用框架</li>
</ul>
<h2 id="rup-rational-unified-process-统一软件开发过程">RUP Rational Unified Process 统一软件开发过程</h2>
<ul>
<li>RUP是现代过程模型的一个实例</li>
<li>RUP描述了如何有效地利用商业的可靠的方法开发和部署软件，是一种重量级过程（也被称作厚方法学），因此特别适用于大型软件团队开发大型项目。<br>
在软件工程领域，与RUP齐名的软件方法还有：</li>
</ul>
<ul>
<li><a href="https://zh.wikipedia.org/w/index.php?title=%E5%87%80%E5%AE%A4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B&amp;action=edit&amp;redlink=1">净室软件工程</a> （重量级）、 <a href="https://zh.wikipedia.org/wiki/CMMI">CMMI</a> （重量级）</li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B">极限编程</a> （extreme programming）和其他 <a href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">敏捷软件开发</a> （agile methodology）方法学（轻量级）</li>
</ul>
<ul>
<li>三个视角<br>
动态视角：给出模型随时间所经历的各个阶段;<br>
静态视角：给出所规定的过程活动;<br>
实践视角：建议在过程中采用的好的实践示例.</li>
</ul>
<h3 id="模型">模型</h3>
<ul>
<li>先启阶段<br>
建立系统的业务案例。识别所有与系统交互的外部实体并定义这些交互。</li>
</ul>
<ul>
<li>精化阶段<br>
增进对问题域的理解，建立系统的体系架构<br>
给出项目计划，及风险的识别</li>
<li>构造<br>
进行系统的设计、编程以及测试.</li>
<li>转换<br>
完成系统的部署。</li>
</ul>
<h3 id="产品生命周期中的指导方针和模板">产品生命周期中的指导方针和模板</h3>
<p>RUP为项目成员定义了在一个产品生命周期中如下指导方针和模板。<br>
<strong>迭代式开发</strong>给定的时间内，开发一个大型的复杂的软件系统，定义问题并构建解决方案是不可能一蹴而就的。在项目的开发过程中，由于体系结构方面的约束，客户的需要或对原始问题更精确的理解，需求会经常地变更。迭代式开发允许通过后续的细化产生对项目更好的理解，并在每个迭代的阶段，把项目的最高风险的事项作为最高优先级的任务集中精力解决。理想的，每一次迭代都以一个可执行的发布为结束，这样可以减少一个项目风险，更多地允许客户的交互并帮助开发人员集中精力。</p>
<p><strong>管理需求</strong>对于任何大型项目来说，一个文档框架是必不可少的；因此RUP描述了如何描述功能性，约束，设计决定和业务需求。<br>
用例和场景是过程规定的制品的例子，在贯穿系统整个开发和部署的过程中，用例和场景在捕捉功能需求和提供一致的线索上是非常有效的。</p>
<p><strong>使用基于构件的体系架构</strong>基于构件的体系架构（CBA）创造了容易扩展的系统，并提升了软件的重用性和可读性。一个构件经常与 <a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象程序设计</a> 中的一个对象有关。<br>
RUP提供了构建这种系统的一个系统化的方法，关注于在把所有资源投入到一个项目之前，开发出一个早期的可执行的体系架构。<br>
这些构件通过一些基础平台，如 <a href="https://zh.wikipedia.org/wiki/CORBA">CORBA</a> 和 <a href="https://zh.wikipedia.org/w/index.php?title=Component_object_model&amp;action=edit&amp;redlink=1">COM</a> 组装在一起。</p>
<p><strong>软件的可视化建模</strong>将你的程序设计从代码上抽象出来，并用图形化构件块展现出来是得到解决方案的全面意象的一种有效方法。这对于项目的技术人员来说，一方面，能够更容易地勾画出如何最好的实现一个给定逻辑集合的轮廓，另一方面，能够更容易地构造在业务过程和实现业务过程的实际代码之间的中间物。<br>
<strong>验证软件品質</strong>品質评估是所有软件项目中最经常的失败所在，因为通常这样项目的仅仅在项目总结中进行质量评估和甚至由另外的团队来进行品質评估。 RUP在规划品質控制和评估方面有所帮助，并把品質控制和评估包括在每个项目成员都参与的整个过程中。</p>
<p><strong>控制软件的变更</strong>在所有的软件项目中，变更是不可避免的，RUP定义了控制和监控变更的方法。一个表面上很小的变更可能以完全不可预计的方式对应用程序产生影响，这一点对一个成功项目至关重要。RUP同时定义了<em>安全的操作环境</em>，保证一个程序员对另一个系统的修改将不会对他系统地修改。这一点与基于构件的体系架构有很大的关系。<br>
迄今为止，这些指导方针是通用的，可以在一个项目的生命周期中遵守。为了把握一个项目的时间尺度，RUP把一个项目分为四个不同的阶段：</p>
<ol>
<li>构思阶段 ：包括用户沟通和计划活动两个方面，强调定义和细化用例，并将其作为主要模型。</li>
<li>细化阶段 ：包括用户沟通和建模活动，重点是创建分析和设计模型，强调类的定义和体系结构的表示。</li>
<li>构建阶段 ：将设计转化为实现，并进行集成和测试。</li>
<li>移交阶段 ：将产品发布给用户进行测试评价，并收集用户的意见，之后再次进行迭代修改产品使之完善。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库原理课程笔记]]></title>
        <id>https://caesaryangs.github.io/post/shu-ju-ku-yuan-li-ke-cheng-bi-ji/</id>
        <link href="https://caesaryangs.github.io/post/shu-ju-ku-yuan-li-ke-cheng-bi-ji/">
        </link>
        <updated>2021-05-09T10:28:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="关于数据库的进阶学习笔记">关于数据库的进阶学习笔记</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机组成原理课程笔记]]></title>
        <id>https://caesaryangs.github.io/post/ji-suan-ji-zu-cheng-yuan-li-ke-cheng-bi-ji/</id>
        <link href="https://caesaryangs.github.io/post/ji-suan-ji-zu-cheng-yuan-li-ke-cheng-bi-ji/">
        </link>
        <updated>2021-03-17T02:04:50.000Z</updated>
        <summary type="html"><![CDATA[<p>--持续更新中--🈶</p>
]]></summary>
        <content type="html"><![CDATA[<p>--持续更新中--🈶</p>
<!-- more -->
<h2 id="绪论">绪论</h2>
<ul>
<li><strong>课程概览</strong>
<ul>
<li>计算机+组成+原理</li>
<li>基本部件的结构和组织方式</li>
<li>基本运算的操作原理</li>
<li>基本部件和单元的设计思想</li>
<li>难点：
<ul>
<li>存储器</li>
<li>计算机运算方法</li>
<li>指令系统</li>
<li>CPU</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- more -->
<h2 id="计算机系统概论">计算机系统概论</h2>
<!-- more -->
<h3 id="计算机系统简介">计算机系统简介</h3>
<ul>
<li>
<p>软硬件概念</p>
<ul>
<li>软件：系统软件+应用软件</li>
<li>考点：系统软件or应用软件</li>
</ul>
</li>
<li>
<p>框图</p>
<ul>
<li>基于此框图进行设计构造</li>
</ul>
</li>
<li>
<p>计算机系统层次结构</p>
<ul>
<li>高级语言-&gt;汇编语言-&gt;<strong>操作系统</strong>-&gt;机器语言-&gt;微指令系统</li>
</ul>
</li>
</ul>
<!-- more -->
<h3 id="计算机基本组成">计算机基本组成</h3>
<ul>
<li>
<p><strong>冯诺依曼计算机特点</strong></p>
<ul>
<li>计算机由五大部件组成
<ul>
<li>输入 输出 存储器 运算器 控制器</li>
</ul>
</li>
<li>指令和数据以同等地位存于储存器 可按地址寻访</li>
<li>指令和数据用二进制表示</li>
<li>指令由操作码和地址码组成</li>
<li>存储程序</li>
<li>以运算器为中心</li>
</ul>
</li>
<li>
<p>计算机硬件框图</p>
<ul>
<li>以储存器为中心的硬件框图</li>
<li>存储墙</li>
</ul>
</li>
<li>
<p>现代计算机硬件框图</p>
<ul>
<li>CPU
<ul>
<li><strong>运算器 ALU</strong></li>
<li><strong>控制器 CU</strong></li>
</ul>
</li>
<li><strong>存储器</strong>
<ul>
<li>主存</li>
<li>辅存</li>
</ul>
</li>
<li><strong>输入设备</strong></li>
<li><strong>输出设备</strong></li>
</ul>
</li>
</ul>
<!-- more -->
<h3 id="计算机工作步骤">计算机工作步骤</h3>
<ul>
<li>指令格式
<ul>
<li>操作码+地址码</li>
</ul>
</li>
<li>寄存器</li>
<li>运算器基本组成及操作过程</li>
</ul>
<!-- more -->
<h2 id="总线">总线</h2>
<ul>
<li>重点：</li>
<li>串行 并行</li>
<li>片内总线</li>
<li>^<sup>系统总线</sup>^</li>
<li>总线的性能指标</li>
<li>总线结构-分析优劣</li>
<li></li>
<li>
<h3 id="超重点-35总线控制">超重点 ^<sup>3.5总线控制</sup>^</h3>
<ul>
<li>从链式查询到控制请求</li>
<li>根据时序逻辑图解释每一步的计算机处理过程</li>
</ul>
</li>
</ul>
<!-- more -->
<h3 id="总线基本概念">总线基本概念</h3>
<ul>
<li>总线的意义
<ul>
<li>总线是连接各个部件的信息传输线 ^<sup>是各个部件共享的传输介质</sup>^</li>
</ul>
</li>
<li>信息传送
<ul>
<li>串行</li>
<li>并行</li>
</ul>
</li>
<li>总线结构举例
<ul>
<li>面向CPU的双总线结构：存储总线+IO总线</li>
<li>单总线(系统总线)</li>
<li>以存储器为中心的双总线结构</li>
</ul>
</li>
</ul>
<!-- more -->
<h3 id="总线的分类">总线的分类</h3>
<ul>
<li>片内总线
<ul>
<li>芯片内部总线</li>
</ul>
</li>
<li>^<sup>系统总线</sup>^
<ul>
<li>计算机各部件间的信息传输线</li>
<li>数据总线：双向-与机器字长，存储字长有关——对应MDR</li>
<li>地址总线：单向-与存储地址，IO地址有关——</li>
<li>控制总线：有出有入</li>
</ul>
</li>
<li>通信总线
<ul>
<li>用于^<sup>计算机系统之间</sup><sup>或</sup><sup>计算机系统与其他系统</sup>^之间的通信</li>
<li>串行</li>
<li>并行</li>
</ul>
</li>
</ul>
<!-- more -->
<h3 id="总线特性及性能指标">总线特性及性能指标</h3>
<ul>
<li>总线物理实现</li>
<li>总线特性
<ul>
<li>机械特性</li>
<li>电气特性 传输方向和有效的点平范围</li>
<li>功能特性 每跟传输线的功能</li>
<li>时间特性 信号的时序关系</li>
</ul>
</li>
<li>总线的性能指标
<ul>
<li>总线宽度：数据线的根数</li>
<li>标准传输率：每秒传输的最大字节数</li>
<li>时钟同步异步</li>
<li>总线复用：地址线与数据线复用</li>
<li>信号线数</li>
<li>^<sup>总线控制方式：突发、自动、仲裁、逻辑、技术</sup>^</li>
<li>其他指标：负载能力</li>
</ul>
</li>
<li>总线标准</li>
</ul>
<!-- more -->
<h3 id="总线结构">总线结构</h3>
<ul>
<li><strong>单总线结构</strong></li>
<li>多总线结构
<ul>
<li>双总线结构</li>
<li>三总线结构
<ul>
<li>主存总线</li>
<li>IO总线</li>
<li>DMA总线：连接主存和高速外设</li>
<li>另一种结构
<ul>
<li>局部总线</li>
<li>系统总线
<ul>
<li>在主存和缓存中交换信息</li>
</ul>
</li>
<li>扩展总线</li>
</ul>
</li>
</ul>
</li>
<li>四总线结构</li>
</ul>
</li>
<li>总线举例
<ul>
<li>PCI总线
<ul>
<li><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSubjects%2Fco4maj5LK_.png?alt=media&amp;token=527607d2-32d2-4b19-a657-8c4dfb5226b4" alt="" loading="lazy"></li>
<li>多层PCI总线结构</li>
</ul>
</li>
</ul>
</li>
<li>中大型计算机典型结构：利用通道</li>
</ul>
<!-- more -->
<h3 id="总线控制">总线控制</h3>
<ul>
<li>总线判优控制
<ul>
<li>
<ol>
<li>基本概念</li>
</ol>
<ul>
<li>主设备对总线有^<sup>控制权</sup>^</li>
<li>^<sup>响应</sup>^从设备相应从主设备发来的总线命令</li>
<li>^<sup>总线判优控制</sup>^
<ul>
<li>^<sup>集中式</sup>^
<ul>
<li>链式查询
<ul>
<li><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSubjects%2FYU9udB-pjY.png?alt=media&amp;token=8f721cab-67f4-41ce-b2d6-c7b55bc7af18" alt="" loading="lazy"></li>
<li>BS-总线忙  BR-总线请求  BG-总线同意</li>
<li>问题
<ul>
<li>高优先级的设备将一直占用总线导致低优先级的设备无法获取总线使用权</li>
<li>容错性差</li>
</ul>
</li>
</ul>
</li>
<li>计数器定时查询
<ul>
<li>BS BR 设备地址线
<ul>
<li><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSubjects%2FEWA6iszgMs.png?alt=media&amp;token=3d5f359c-28c2-402c-abe1-d8fb51294d81" alt="" loading="lazy"></li>
<li>优点
<ul>
<li>总线控制部件依次向下问询</li>
<li>容错性较好</li>
<li>^^优先级不固定 计数器初始值可人为指定 灵活指定优先级^^</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>独立请求方式
<ul>
<li>排队器+每个IO接口独立接入总线控制部件</li>
<li>缺点
<ul>
<li>每个IO设备占用两条控制线 成本高</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>分布式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- more -->
<h3 id="总线通信控制">总线通信控制</h3>
<ul>
<li>总线通信控制
<ul>
<li>目的：解决通信双方协调配合的问题</li>
<li>总线传输周期
<ul>
<li>申请分配阶段：主模块申请，总线仲裁决定</li>
<li>寻址阶段：主模块向从模块给出地址和命令</li>
<li>传数阶段</li>
<li>结束阶段</li>
</ul>
</li>
<li>^<sup>总线通信的四种方式</sup>^
<ul>
<li>同步通信
<ul>
<li>由^<sup>统一时标</sup>^控制数据传送</li>
<li>同步式数据输入
<ul>
<li><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSubjects%2Fo3IgnOOjQg.png?alt=media&amp;token=eed7d721-2e89-48f4-96a8-d886d5526615" alt="" loading="lazy"></li>
<li><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSubjects%2F1N81etIASx.png?alt=media&amp;token=e725e8e0-c702-43af-870c-d77e9f74ad94" alt="" loading="lazy"></li>
<li>最早给出地址信号 最后撤出地址信号</li>
</ul>
</li>
</ul>
</li>
<li>异步通信
<ul>
<li>采用^<sup>应答方式</sup>^，没有公共时钟标准</li>
<li>异步通信
<ul>
<li><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSubjects%2FO9R-HO2zv5.png?alt=media&amp;token=902a6363-de76-4aca-887e-06f2190def81" alt="" loading="lazy"></li>
<li>应答机制</li>
<li>不互锁</li>
<li>半互锁</li>
<li>全互锁—TCP网络协议</li>
</ul>
</li>
</ul>
</li>
<li>半同步通信
<ul>
<li>^<sup>同步，异步结合</sup>^</li>
<li>同步异步结合</li>
<li>同步
<ul>
<li>发送方使用时钟前沿发信号</li>
<li>接收方使用时钟后沿判断识别</li>
</ul>
</li>
<li>异步
<ul>
<li>允许不同速度的模块同时工作</li>
</ul>
</li>
<li>通信方式共同点
<ul>
<li>主模块发地址和命令 ^<sup>占用总线</sup>^</li>
<li>从模块准备数据 ^<sup>不占用总线</sup>^</li>
<li>送模块向主模块发数据 ^<sup>占用总线</sup>^</li>
</ul>
</li>
</ul>
</li>
<li>分离式通信
<ul>
<li>充分^<sup>挖掘</sup><sup>系统</sup><sup>总线每瞬间的潜力</sup>^</li>
<li>一个总线传输周期
<ul>
<li>子周期1 主模块申请占用总线，使用完放弃总线</li>
<li>子周期2 从主模块申请占用总线</li>
</ul>
</li>
<li>特点：
<ul>
<li>各模块有权申请占用总线</li>
<li>采用同步通信方式，不占用总线</li>
<li>各模块准备数据时，不占用总线</li>
<li>总线被占用时，无空闲</li>
<li>^<sup>充分发挥了总线的有效占用</sup>^</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- more -->
<h2 id="计算机运算方法6">计算机运算方法（6）</h2>
<!-- more -->
<h3 id="61-无符号数和有符号数">6.1 无符号数和有符号数</h3>
<ul>
<li>6.1.1无符号数#[[第六章 计算机运算方法]]
<ul>
<li>寄存器的位数 放多少个0/1</li>
<li>反应无符号数的表示范围</li>
</ul>
</li>
<li>6.1.2有符号数#[[第六章 计算机运算方法]]
<ul>
<li>机器数与真值
<ul>
<li>真值：带符号的数
<ul>
<li>真值表示法</li>
</ul>
</li>
<li>机器数：符号数字化的数</li>
</ul>
</li>
</ul>
</li>
<li>6.1.3原码表示法#[[第六章 计算机运算方法]]#[[计算机码]]
<ul>
<li>定义：第一位表示符号 后面表示数</li>
<li><strong>注意小数的表示</strong> 第一位表示符号</li>
<li>补充位数到寄存器的位数</li>
</ul>
</li>
<li>&quot;6.1.4补码表示法#[[第六章 计算机运算方法]]&quot;
<ul>
<li>&quot;与负数等价的正数代替负数&quot;</li>
<li>&quot;补的概念&quot;
<ul>
<li>&quot;利用时钟为例 mod&quot;
<ul>
<li>&quot;<strong>寄存器长度有限=mod</strong>&quot;</li>
</ul>
</li>
<li>&quot;补数&quot;</li>
<li>&quot;结论&quot;
<ul>
<li>&quot;一个负数加上模即得该负数的补数&quot;</li>
<li>&quot;一个正数和一个附属互为补数时 他们的绝对值之和即为模数&quot;</li>
<li>&quot;正数的补数是其本身&quot;</li>
</ul>
</li>
</ul>
</li>
<li>&quot;补码定义&quot;
<ul>
<li>&quot;用数表示符号-码&quot;</li>
<li>&quot;整数&quot;
<ul>
<li>&quot;<img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSubjects%2Fa1Kf0AcRJf.png?alt=media&amp;token=237929d2-52a9-4dee-8f97-3b141564752a" alt="" loading="lazy">&quot;</li>
</ul>
</li>
<li>&quot;小数&quot;
<ul>
<li>&quot;<img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSubjects%2FiNwMaB6fkO.png?alt=media&amp;token=538bcd3c-545d-4c65-a3ea-4c6af5359ac4" alt="" loading="lazy">&quot;</li>
</ul>
</li>
<li>&quot;求补码的快捷方式&quot;
<ul>
<li>&quot;按位取反 末尾加1 (用原码取反 )&quot;</li>
</ul>
</li>
<li>&quot;^<sup>**补码多表示一个数**</sup>^&quot;
<ul>
<li>&quot;-128&quot;</li>
<li>&quot;-1&quot;</li>
<li>&quot;不能按位取反&quot;</li>
</ul>
</li>
</ul>
</li>
<li>&quot;*反码&quot;</li>
<li>&quot;移码&quot;
<ul>
<li>&quot;补码很难判断其真值的大小&quot;</li>
<li>&quot;定义&quot;
<ul>
<li>&quot;<img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSubjects%2FexokFrwFdN.png?alt=media&amp;token=d3ae590a-176c-4da8-9337-69871b8c3689" alt="" loading="lazy">&quot;</li>
</ul>
</li>
<li>&quot;与补码的比较&quot;
<ul>
<li>&quot;<strong>基本相同 只有最高符号位不同 数值位完全相同</strong>&quot;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- more -->
<h3 id="数的定点表示和浮点表示">数的定点表示和浮点表示</h3>
<!-- more -->
<h3 id="定点运算">定点运算</h3>
<pre><code>- 移位的意义
    - 移数 因为是定点机
- 算数移位规则
    - 补码：^^左移添0 右移添1^^
    - 其他码制：直接补0
    - 硬件实现
- 加减法运算
    - 补码
        - 加法 补码相加取反
        - 减法
        - 连同符号为一起相加，符号位产生的进位（最高位）自然丢掉
- 溢出判断#[[判断溢出]]
    - 一位符号判别溢出
        - ⊕异或操作 异或=1溢出
        - 最高有效位仅为⊕符号位进位=1 溢出
    - 两位符号位判断溢出
        - 符号位之前加一位原始符号位 判断是否相同来判断溢出
        - ^^最高符号位代表真正的符号^^
- 补码加减法的硬件配置
- &quot;乘法运算&quot;
    - &quot;笔算乘法改进-递推公式-对于原码&quot;
        - &quot;初始状态&quot;
        - &quot;带乘数移位&quot;
        - &quot;移位n次，加n次&quot;
    - &quot;**补码乘法**&quot;
        - &quot;__目的：不需要管原来的真正的数是什么，只需要这个码来运行即可__&quot;
        - &quot;原始方法&quot;
            - &quot;被乘数任意，乘数为正&quot;
                - &quot;同原码乘&quot;
                - &quot;但加和移位按补码规则运算&quot;
                - &quot;运算乘积的符号自然形成&quot;
            - &quot;被乘数任意，乘数为负&quot;
                - &quot;乘数补 去掉符号位 操作同上&quot;
        - &quot;^^Booth算法^^&quot;
            - &quot;一位乘&quot;
            - &quot;两位乘&quot;
</code></pre>
<!-- more -->
<h3 id="浮点四则运算">浮点四则运算</h3>
<!-- more -->
<h3 id="算术逻辑单元">算术逻辑单元</h3>
<!-- more -->
<h2 id="指令系统7">指令系统（7）</h2>
<!-- more -->
<h3 id="机器指令">机器指令</h3>
<!-- more -->
<h3 id="操作数类型和操作类型">操作数类型和操作类型</h3>
<!-- more -->
<h3 id="寻址方式">寻址方式</h3>
<!-- more -->
<h3 id="指令格式举例">指令格式举例</h3>
<!-- more -->
<h3 id="risc详解">RISC详解</h3>
<!-- more -->
<h2 id="存储器">存储器</h2>
<!-- more -->
<h3 id="概述">概述</h3>
<ol>
<li>存储器分类</li>
</ol>
<ul>
<li>按存储介质分类</li>
<li>按存取方式分类
<ul>
<li>存取时间与物理地址无关（随机访问）
<ul>
<li>随机存储器</li>
<li>只读存储器</li>
</ul>
</li>
<li>存取时间与物理地址有关（串行访问）</li>
</ul>
</li>
<li>存储器的层次结构
<ul>
<li>存储器速度 容量 价格特征关系</li>
</ul>
</li>
</ul>
<ol start="2">
<li>缓存-主存层次 主存-辅存层次</li>
</ol>
<!-- more -->
<h3 id="主存储器">主存储器</h3>
<ul>
<li>
<p>概述</p>
<ol>
<li>主存的基本组成：存储体 读写电路 驱动器 译码器 控制电路 MDR</li>
<li>主存和CPU的连接</li>
<li>主存中储存单元地址的分配<br>
高位字节 地址为字地址<br>
低位字节 地址为字地址</li>
<li>主存的技术指标<br>
存储容量-主存存放二进制代码的总数量<br>
存储速度-存取时间（存储器访问时间）+存取周期（连续两次独立的存储器操作所需的最小间隔时间）<br>
存储器带宽</li>
</ol>
</li>
<li>
<p>半导体存储芯片</p>
<ol>
<li>基本结构</li>
</ol>
<ul>
<li>CS是片选信号，WE是读写控制信号（低电平写 高电平读）</li>
</ul>
<ol start="2">
<li>译码驱动方式
<ul>
<li>线选法</li>
<li>重合法</li>
</ul>
</li>
</ol>
</li>
<li>
<p>只读存储器ROM</p>
<ul>
<li>掩膜ROM</li>
<li>PROM 一次性编程</li>
<li>EPROM 多次性编程</li>
<li>EEPROM 多次性编程</li>
<li>Flash Memory 快擦型存储器</li>
</ul>
</li>
<li>
<p>::<strong>存储器与CPU的连接</strong>::</p>
<ol>
<li>存储器容量的扩展</li>
</ol>
<ul>
<li>位扩展</li>
<li>字扩展</li>
<li>字，位扩展</li>
</ul>
<ol start="2">
<li>存储器与CPU的连接<br>
地址线连接 数据线连接 读写线连接 片选线连接 合理选用芯片<br>
其他：时许，负载等</li>
</ol>
</li>
<li>
<p>提高访存速度的措施</p>
<ul>
<li>单体多字系统——增加存储器带宽</li>
<li>多体并行系统
<ul>
<li>高位交叉：各个体并行工作<br>
需要上层操作系统帮助提升性能</li>
<li>低位交叉：各个体轮流编址<br>
<strong>在不改变存取周期的前提下增加存储器带宽</strong><br>
利用程序的局部性原理<br>
低位地址选择使用哪个存储器<br>
高位地址选地址块<br>
在cpu工作时同时进行取指令的操作 类似于并行 提高访存效</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- more -->
<h3 id="高速缓冲存储器cache">高速缓冲存储器Cache</h3>
<h3 id="概述-2">概述</h3>
<ul>
<li>Cache的工作原理
<ol>
<li>主存和缓存的编址<br>
主存和缓存按块存储 块的大小相同</li>
<li>命中与未命中<br>
命中：主存块调入缓存 主存块与缓存块建立了对应关系 用标记记录与某缓存块建立了对应关系的主存块块号</li>
<li>Cache的基本结构</li>
</ol>
</li>
</ul>
<h3 id="cache-主存的地址映像">Cache-主存的地址映像</h3>
<ul>
<li>直接映像：每个缓存块可以和若干主存块对应 每个主存块只能和一个缓存块对应</li>
<li>全相连映像：主存中的任一块可以映射到缓存中的任一块 利用率高但速度较慢</li>
<li>组相连映像</li>
</ul>
]]></content>
    </entry>
</feed>